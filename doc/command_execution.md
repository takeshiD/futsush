# コマンド実行
bashなどのシェルでは既に実装されている`ls`や`gcc`などのプログラム名を打ち込むと実行できます。
```sh
$ ls
README.md main.c
$ gcc ./main.c # a.outが出力される
```
あまりにも当たり前すぎて何の疑問も持ちにくいのですが、これはシステムコール`exec`に対してコマンドを表す文字列を渡すことで実行をしており、シェルはその橋渡しをしているだけです。

## プロセスに関わるシステムコール
シェルがコマンドを実行するときに使うシステムコールを紹介しましょう。

### fork
forkをプロセス内で呼び出すと、呼び出した時点からの状態でそのプロセスを2つに複製します。
呼び出し元のプロセスを親プロセス、複製されたプロセスを子プロセスと言います。子プロセスは正常に終了すると親プロセスに対してSIGCHLDというシグナルを送信します。

### exec
execに成功するとその時点で自プロセスは書き換えられます。失敗すると書き換えられずに自プロセスが継続します。

### wait
forkした子プロセスの終了はwaitによって待たなければなりません。
プロセス自体は終了したが、waitによって終了が待たれる機会を失ったプロセスはゾンビと言われます。


### fork-exec
Linuxではプロセスを実行する手法として次の手順が一般的です。

1. forkをする
2. 子プロセスでexecを実行する
3. 親プロセスでwaitして子プロセスの終了を待つ(この間、親プロセスは停止する)
4. 子プロセスが終了し、親プロセスにSIGCHLDを送信する
5. 親プロセスが再開する

これをfork-execと呼びます。
図にすると以下のようになります。

![](/doc/img/fork-exec-wait.svg)

# 1つのコマンドを実行するプログラム
シェルの第1歩として、コマンドライン引数に指定した文字列をコマンドとして実行するプログラムを作ってみましょう。


```c
#include <unistd.h>
#include <sys/type.h>
int main(int argc, char* argv[])
{

}
```